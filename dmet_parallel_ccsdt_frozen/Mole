#INFO: **** input file is /home/yuliya/anaconda3/lib/python3.6/cProfile.py ****
#! /usr/bin/env python3

"""Python interface for the 'lsprof' profiler.
   Compatible with the 'profile' module.
"""

__all__ = ["run", "runctx", "Profile"]

import _lsprof
import profile as _pyprofile

# ____________________________________________________________
# Simple interface

def run(statement, filename=None, sort=-1):
    return _pyprofile._Utils(Profile).run(statement, filename, sort)

def runctx(statement, globals, locals, filename=None, sort=-1):
    return _pyprofile._Utils(Profile).runctx(statement, globals, locals,
                                             filename, sort)

run.__doc__ = _pyprofile.run.__doc__
runctx.__doc__ = _pyprofile.runctx.__doc__

# ____________________________________________________________

class Profile(_lsprof.Profiler):
    """Profile(custom_timer=None, time_unit=None, subcalls=True, builtins=True)

    Builds a profiler object using the specified timer function.
    The default timer is a fast built-in one based on real time.
    For custom timer functions returning integers, time_unit can
    be a float specifying a scale (i.e. how long each integer unit
    is, in seconds).
    """

    # Most of the functionality is in the base class.
    # This subclass only adds convenient and backward-compatible methods.

    def print_stats(self, sort=-1):
        import pstats
        pstats.Stats(self).strip_dirs().sort_stats(sort).print_stats()

    def dump_stats(self, file):
        import marshal
        with open(file, 'wb') as f:
            self.create_stats()
            marshal.dump(self.stats, f)

    def create_stats(self):
        self.disable()
        self.snapshot_stats()

    def snapshot_stats(self):
        entries = self.getstats()
        self.stats = {}
        callersdicts = {}
        # call information
        for entry in entries:
            func = label(entry.code)
            nc = entry.callcount         # ncalls column of pstats (before '/')
            cc = nc - entry.reccallcount # ncalls column of pstats (after '/')
            tt = entry.inlinetime        # tottime column of pstats
            ct = entry.totaltime         # cumtime column of pstats
            callers = {}
            callersdicts[id(entry.code)] = callers
            self.stats[func] = cc, nc, tt, ct, callers
        # subcall information
        for entry in entries:
            if entry.calls:
                func = label(entry.code)
                for subentry in entry.calls:
                    try:
                        callers = callersdicts[id(subentry.code)]
                    except KeyError:
                        continue
                    nc = subentry.callcount
                    cc = nc - subentry.reccallcount
                    tt = subentry.inlinetime
                    ct = subentry.totaltime
                    if func in callers:
                        prev = callers[func]
                        nc += prev[0]
                        cc += prev[1]
                        tt += prev[2]
                        ct += prev[3]
                    callers[func] = nc, cc, tt, ct

    # The following two methods can be called by clients to use
    # a profiler to profile a statement, given as a string.

    def run(self, cmd):
        import __main__
        dict = __main__.__dict__
        return self.runctx(cmd, dict, dict)

    def runctx(self, cmd, globals, locals):
        self.enable()
        try:
            exec(cmd, globals, locals)
        finally:
            self.disable()
        return self

    # This method is more useful to profile a single function call.
    def runcall(self, func, *args, **kw):
        self.enable()
        try:
            return func(*args, **kw)
        finally:
            self.disable()

# ____________________________________________________________

def label(code):
    if isinstance(code, str):
        return ('~', 0, code)    # built-in functions ('~' sorts at the end)
    else:
        return (code.co_filename, code.co_firstlineno, code.co_name)

# ____________________________________________________________

def main():
    import os, sys
    from optparse import OptionParser
    usage = "cProfile.py [-o output_file_path] [-s sort] scriptfile [arg] ..."
    parser = OptionParser(usage=usage)
    parser.allow_interspersed_args = False
    parser.add_option('-o', '--outfile', dest="outfile",
        help="Save stats to <outfile>", default=None)
    parser.add_option('-s', '--sort', dest="sort",
        help="Sort order when printing to stdout, based on pstats.Stats class",
        default=-1)

    if not sys.argv[1:]:
        parser.print_usage()
        sys.exit(2)

    (options, args) = parser.parse_args()
    sys.argv[:] = args

    if len(args) > 0:
        progname = args[0]
        sys.path.insert(0, os.path.dirname(progname))
        with open(progname, 'rb') as fp:
            code = compile(fp.read(), progname, 'exec')
        globs = {
            '__file__': progname,
            '__name__': '__main__',
            '__package__': None,
            '__cached__': None,
        }
        runctx(code, globs, None, options.outfile, options.sort)
    else:
        parser.print_usage()
    return parser

# When invoked as main program, invoke the profiler on a script
if __name__ == '__main__':
    main()
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='yuliya-Precision-T1650', release='3.19.0-32-generic', version='#37~14.04.1-Ubuntu SMP Thu Oct 22 09:41:40 UTC 2015', machine='x86_64', processor='x86_64')  Threads 8
Python 3.6.6 |Anaconda custom (64-bit)| (default, Jun 28 2018, 17:14:51) 
[GCC 7.2.0]
numpy 1.14.5  scipy 1.1.0
Date: Thu Aug 30 17:46:56 2018
PySCF version 1.3
PySCF path  /home/yuliya/pyscf/pyscf
[INPUT] VERBOSE 4
[INPUT] num atoms = 8
[INPUT] num electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT]  1 C      0.000000000000   0.000000000000   0.768000000000 AA    0.000000000000   0.000000000000   1.451309663666 Bohr
[INPUT]  2 C      0.000000000000   0.000000000000  -0.768000000000 AA    0.000000000000   0.000000000000  -1.451309663666 Bohr
[INPUT]  3 H     -1.019200000000   0.000000000000   1.157300000000 AA   -1.926008866157   0.000000000000   2.186980043959 Bohr
[INPUT]  4 H      0.509600000000   0.882600000000   1.157300000000 AA    0.963004433078   1.667872277541   2.186980043959 Bohr
[INPUT]  5 H      0.509600000000  -0.882600000000   1.157300000000 AA    0.963004433078  -1.667872277541   2.186980043959 Bohr
[INPUT]  6 H      1.019200000000   0.000000000000  -1.157300000000 AA    1.926008866157   0.000000000000  -2.186980043959 Bohr
[INPUT]  7 H     -0.509600000000  -0.882600000000  -1.157300000000 AA   -0.963004433078  -1.667872277541  -2.186980043959 Bohr
[INPUT]  8 H     -0.509600000000   0.882600000000  -1.157300000000 AA   -0.963004433078   1.667872277541  -2.186980043959 Bohr
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] C
[INPUT] 0    0    [8    /2   ]  6665              0.000692 -0.000146
                                1000              0.005329 -0.001154
                                228               0.027077 -0.005725
                                64.71             0.101718 -0.023312
                                21.06             0.27474 -0.063955
                                7.495             0.448564 -0.149981
                                2.797             0.285074 -0.127262
                                0.5215            0.015204 0.544529
[INPUT] 0    0    [1    /1   ]  0.1596               1
[INPUT] 1    0    [3    /1   ]  9.439             0.038109
                                2.002             0.20948
                                0.5456            0.508557
[INPUT] 1    0    [1    /1   ]  0.1517               1
[INPUT] 2    0    [1    /1   ]  0.55                 1
[INPUT] H
[INPUT] 0    0    [3    /1   ]  13.01             0.019685
                                1.962             0.137977
                                0.4446            0.478148
[INPUT] 0    0    [1    /1   ]  0.122                1
[INPUT] 1    0    [1    /1   ]  0.727                1
nuclear repulsion = 42.1780189499367
number of shells = 28
number of NR pGTOs = 94
number of NR cGTOs = 58
basis = {'C': 'cc-pvdz', 'H': 'cc-pvdz'}
ecp = None
CPU time:       382.31




******** <class 'pyscf.scf.hf.RHF'> flags ********
method = RHF
initial guess = minao
damping factor = 0
level shift factor = 0
Do DIIS = True
DIIS start cycle = 1
DIIS space = 8
SCF tol = 1e-06
SCF gradient tol = None
max. SCF cycles = 5000
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /home/yuliya/git/DMET/dmet_parallel_ccsdt_frozen/tmponu_t90n
max_memory 4000 MB (current use 175 MB)
******** <class 'pyscf.scf.hf.RHF'> Newton solver flags ********
SCF tol = 1e-06
conv_tol_grad = None
max. SCF cycles = 5000
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /home/yuliya/git/DMET/dmet_parallel_ccsdt_frozen/tmponu_t90n
max_cycle_inner = 10
max_stepsize = 0.05
ah_start_tol = 5
ah_level_shift = 0
ah_conv_tol = 1e-12
ah_lindep = 1e-14
ah_start_cycle = 1
ah_max_cycle = 30
ah_grad_trust_region = 2.5
kf_interval = 5
kf_trust_region = 5
max_memory 4000 MB (current use 175 MB)
  HOMO = -0.413406395044631  LUMO = 0.115932018532765
Set conv_tol_grad to 0.001
  HOMO = -0.477923372488811  LUMO = 0.186382016715074
macro= 0  E= -79.2348548726447  delta_E= -79.2349  |g|= 0.00484145  7 JK
macro= 1  E= -79.2348548728496  delta_E= -2.04878e-10  |g|= 0.000394604  2 JK
Canonicalize SCF orbitals
macro X = 2  E=-79.2348548728496  |g|= 0.000394604  total 9 JK
converged SCF energy = -79.2348548728496
Localizer :: At iteration 0 the cost function = 1062.4570158743384
Localizer :: Linear size of the augmented Hessian = 92
Localizer :: Taking half a step back
Localizer :: Gradient norm = 155.763
Localizer :: Update norm   = 13.4073
Localizer :: At iteration 1 the cost function = 1067.8101029619531
             Diff. with prev. CF = 5.35309
             Diff. with max.  CF = 0
Localizer :: Taking half a step back
Localizer :: Taking half a step back
Localizer :: Taking half a step back
Localizer :: Gradient norm = 140.704
Localizer :: Update norm   = 99.1334
Localizer :: At iteration 2 the cost function = 1086.2309923774219
             Diff. with prev. CF = 18.4209
             Diff. with max.  CF = 0
Localizer :: Gradient norm = 161.311
Localizer :: Update norm   = 1.38707
Localizer :: At iteration 3 the cost function = 1148.7142693235517
             Diff. with prev. CF = 62.4833
             Diff. with max.  CF = 0
Localizer :: Gradient norm = 39.3756
Localizer :: Update norm   = 0.320013
Localizer :: At iteration 4 the cost function = 1153.0922380264371
             Diff. with prev. CF = 4.37797
             Diff. with max.  CF = 0
Localizer :: Gradient norm = 2.73195
Localizer :: Update norm   = 0.0276755
Localizer :: At iteration 5 the cost function = 1153.1264716959388
             Diff. with prev. CF = 0.0342337
             Diff. with max.  CF = 0
Localizer :: Gradient norm = 0.0246798
Localizer :: Update norm   = 0.000237563
Localizer :: At iteration 6 the cost function = 1153.1264745330175
             Diff. with prev. CF = 2.83708e-06
             Diff. with max.  CF = 0
Localizer :: Gradient norm = 2.05613e-06
Localizer :: Update norm   = 2.6637e-08
Localizer :: At iteration 7 the cost function = 1153.1264745330177
             Diff. with prev. CF = 2.27374e-13
             Diff. with max.  CF = 0
Localization procedure converged in 7 iterations.


******** <class 'pyscf.df.df_jk.density_fit.<locals>.DFHF'> flags ********
method = DFHF
initial guess = minao
damping factor = 0
level shift factor = 0
Do DIIS = True
DIIS start cycle = 1
DIIS space = 8
SCF tol = 1e-09
SCF gradient tol = None
max. SCF cycles = 50
direct_scf = False
chkfile to save SCF result = /home/yuliya/git/DMET/dmet_parallel_ccsdt_frozen/tmpk6pw4tdw
max_memory 4000 MB (current use 198 MB)
Set gradient conv threshold to 3.16228e-05
init E= -79.3796620478739
  HOMO = -0.413366790750012  LUMO = 0.116153141412601
cycle= 1 E= -79.2174974882352  delta_E= 0.162  |g|= 0.224  |ddm|= 2.15
  HOMO = -0.477933073981835  LUMO = 0.186590495287258
cycle= 2 E= -79.2331797609643  delta_E= -0.0157  |g|= 0.0599  |ddm|= 0.17
  HOMO = -0.492010889520311  LUMO = 0.184087727060028
cycle= 3 E= -79.2343606313195  delta_E= -0.00118  |g|= 0.0229  |ddm|= 0.0579
  HOMO = -0.485981598996815  LUMO = 0.186892602496766
cycle= 4 E= -79.2345186744655  delta_E= -0.000158  |g|= 0.00196  |ddm|= 0.018
  HOMO = -0.486519493704695  LUMO = 0.186702022626925
cycle= 5 E= -79.2345204796314  delta_E= -1.81e-06  |g|= 0.000324  |ddm|= 0.00337
  HOMO = -0.486512182895265  LUMO = 0.18668663145932
cycle= 6 E= -79.2345205480102  delta_E= -6.84e-08  |g|= 7.21e-05  |ddm|= 0.000827
  HOMO = -0.48652806489224  LUMO = 0.18667709296479
cycle= 7 E= -79.2345205504028  delta_E= -2.39e-09  |g|= 3.58e-06  |ddm|= 0.000159
  HOMO = -0.486527661487988  LUMO = 0.186677031162883
cycle= 8 E= -79.234520550408  delta_E= -5.22e-12  |g|= 3.99e-07  |ddm|= 7.36e-06
  HOMO = -0.486527632812217  LUMO = 0.186677055949403
converged SCF energy = -79.234520550408
